#!/usr/bin/env python

import json
import socket


def parse_state(response):
    return response["playback_state"]


def parse_song(response):
    pos = response["current"]
    if pos is None:
        return

    queue = response["queue"]
    if len(queue) < pos:
        return
    return queue[pos]["path"]


def parse_metadata(response, tags):
    metadata = response["metadata"][0]
    return [metadata[tag] for tag in tags]


def get_response(request):
    msg_bytes = bytes(request, "utf8")
    n = len(msg_bytes)
    s.sendall(n.to_bytes(4, "big"))
    s.sendall(msg_bytes)
    expected_len = int.from_bytes(s.recv(4), "big")
    response = bytearray()
    while len(response) < expected_len:
        response.extend(s.recv(expected_len))

    return response


PORT = 2137
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(("localhost", PORT))
response_len = int.from_bytes(s.recv(4), "big")
response = s.recv(response_len)

request = json.dumps({"kind": "state"})
response_state = json.loads(get_response(request))

state = parse_state(response_state)
if state == "stopped":
    print("musing off")
else:
    if state == "playing":
        print(" ", end="")
    else:
        print(" ", end="")
    song = parse_song(response_state)
    tags = ["artist", "tracktitle"]
    request = json.dumps({"kind": "metadata", "paths": [song], "tags": tags})
    response_metadata = json.loads(get_response(request))
    (artist, title) = parse_metadata(response_metadata, tags)
    print(f"{artist} - {title}")
